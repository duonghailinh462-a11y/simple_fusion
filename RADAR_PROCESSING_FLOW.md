# 雷达处理流程梳理

## 初始流程（原始设计）

```
雷达数据到达
    ↓
[第一道关卡] 地理区域过滤 (RadarDataFilter.batch_filter_radar_data)
    ├─ 融合区域内 → fusion_radar_data
    │   ↓
    │   [第二道关卡] 按摄像头融合 (RadarVisionFusionProcessor.process_frame)
    │   ├─ 与视觉目标匹配
    │   ├─ 更新 radar_id_map (track_id -> radar_id)
    │   └─ 更新 plate 字段（只在输出时使用）
    │
    └─ 融合区域外 → direct_radar_outputs
        ↓
        [直接输出] 立即输出到 JSON
        ├─ timestamp: 雷达原始时间戳
        ├─ source: "radar"
        └─ 不需要轨迹，只输出位置信息
```

## 新增需求（时间对齐）

**问题**：融合区外的雷达数据立即输出，导致时间戳不一致，显示端看到"所有目标同时消失又同时出现"

**原因分析**：
- 视觉数据：T时刻处理，输出时间戳为T
- 雷达数据（融合区外）：T-1秒到达，立即输出时间戳为T-1
- 结果：显示端看到不同时间的数据混在一起，造成视觉混乱

**新流程**：
```
雷达数据到达
    ↓
[第一道关卡] 地理区域过滤
    ├─ 融合区域内 → fusion_radar_data
    │   ↓
    │   [第二道关卡] 按摄像头融合
    │   ├─ 与视觉目标匹配
    │   ├─ 更新 radar_id_map
    │   └─ 更新 plate 字段
    │
    └─ 融合区域外 → direct_radar_outputs
        ↓
        [缓冲] 存入 ResultBuffer.pending_radar_data
        ↓
        [时间对齐] 等待视觉数据处理
        ↓
        [合并输出] 与视觉数据在同一个 reportTime 输出
        ├─ reportTime: 视觉处理时间
        ├─ participant[视觉]: timestamp = 视觉时间戳
        ├─ participant[雷达]: timestamp = 雷达原始时间戳
        └─ 所有数据在同一个 reportTime 中
```

## 关键改变点

### 1. 雷达数据的生命周期

**之前**：
```
直接输出 → 立即写入JSON → 完成
```

**现在**：
```
过滤 → 缓冲 (pending_radar_data) → 等待视觉数据 → 合并输出 → 清理
```

### 2. 时间戳处理

| 数据类型 | 原始时间戳 | 输出时间戳 | 说明 |
|---------|----------|----------|------|
| 视觉数据 | 视觉帧时间 | 视觉帧时间 | 保持原始时间 |
| 雷达数据（融合区内） | 雷达时间 | 视觉时间 | 与视觉融合，使用视觉时间 |
| 雷达数据（融合区外） | 雷达时间 | 雷达时间 | 保持原始时间 |
| reportTime | - | 视觉处理时间 | 整个报告的时间戳 |

### 3. 关键代码位置

**雷达过滤和分类**：
- `radar/RadarFusionOrchestrator.py` 第98-104行
- 返回：`fusion_radar_data`（融合区内）和 `direct_radar_outputs`（融合区外）

**雷达数据缓冲**：
- `core/ResultBuffer.py` 第193-211行
- `add_radar_data()` 方法：接收 `direct_radar_outputs`，存入 `pending_radar_data`

**雷达数据输出**：
- `core/ResultBuffer.py` 第373-430行
- `_perform_triple_matching()` 方法：
  - 遍历 `pending_radar_data`
  - 为每个雷达数据创建 `participant` 对象
  - 保持雷达原始时间戳
  - **关键**：输出后立即清理 `pending_radar_data`

## 当前问题与解决

### 问题1：雷达数据时间戳丢失

**症状**：一秒钟上传了多个雷达数据（5-10帧），但显示出来的时间戳都是一样的

**原因**：
1. 原来使用"替换策略"：新雷达数据到达时，整个 `pending_radar_data` 被替换
2. 这导致只有最后一批雷达数据被保留，之前的数据被丢弃
3. 多个雷达数据的时间戳信息丢失

**解决**：
改为"累积策略"（第193-226行）：
- 新的雷达数据到达 → 添加到 `pending_radar_data`（不覆盖）
- 使用 `radar_id` 作为去重键，防止同一个雷达被重复添加
- 每个雷达数据都保持其原始时间戳
- 输出后再清理

### 问题2：雷达数据重复输出

**症状**：同一批雷达数据被输出多帧

**原因**：
1. `pending_radar_data` 在输出后没有及时清理
2. 下一帧视觉数据到达时，旧的雷达数据仍在缓冲中
3. 导致同一批雷达数据被重复输出

**解决**：
在 `_perform_triple_matching()` 的第423行，每次输出后都执行：
```python
self.pending_radar_data.clear()
```

### 问题：时间戳一致性

**症状**：所有数据使用相同的时间戳

**原因**：之前的实现将所有数据的 `timestamp` 都改成了融合时间

**解决**：
- 视觉数据：使用 `global_target.last_seen_timestamp`（原始视觉时间）
- 雷达数据：使用 `radar_data.get('timestamp')`（原始雷达时间）
- reportTime：使用融合时的时间戳（整个报告的时间）

## 数据流示例

### 场景：视觉帧T、雷达帧T-1秒

```
时刻 T-1秒：
  雷达数据到达 → 过滤 → 融合区外的直接输出
  ├─ 融合区内：进行匹配，更新 radar_id_map
  └─ 融合区外：存入 pending_radar_data

时刻 T：
  视觉数据到达 → 处理 → 三路匹配
  ├─ 收集全局目标
  ├─ 合并 pending_radar_data 中的雷达数据
  ├─ 生成 JSON：
  │  {
  │    "reportTime": T的毫秒时间戳,
  │    "participant": [
  │      {"timestamp": "T的时间戳", "source": "camera", ...},  // 视觉数据
  │      {"timestamp": "T-1秒的时间戳", "source": "radar", ...} // 雷达数据
  │    ]
  │  }
  └─ 清理 pending_radar_data

时刻 T+1：
  新的视觉数据到达，pending_radar_data 已为空
  └─ 如果有新的雷达数据，才会被添加
```

## 为什么这样做能解决"同时消失"问题

### 原始问题
- 视觉目标和雷达目标的时间戳不一致
- 显示端收到混乱的时间戳，无法正确渲染
- 导致视觉上的"闪烁"或"同时消失"

### 新方案的优势
1. **时间对齐**：所有数据在同一个 `reportTime` 中输出
2. **时间戳保留**：每个数据保持其原始时间戳，便于显示端理解数据来源
3. **清理及时**：雷达数据输出后立即清理，防止重复
4. **一致性**：同一帧内的所有数据都是"同一时刻"的融合结果

## 待验证的问题

1. **显示端是否正确处理混合时间戳**？
   - 视觉数据时间戳 ≈ T
   - 雷达数据时间戳 ≈ T-1秒
   - 显示端需要理解这是"融合结果"而不是"时间混乱"

2. **雷达数据的频率是否足够**？
   - 如果雷达数据更新频率低，可能导致某些帧没有新的雷达数据
   - 需要确认这是否会导致视觉上的"雷达目标消失"

3. **reportTime 的含义**？
   - 应该代表"融合处理完成的时间"
   - 还是应该代表"数据的平均时间"？
